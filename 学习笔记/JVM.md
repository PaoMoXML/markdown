### JVM结构

![JVM结构](https://cdn.jsdelivr.net/gh/PaoMoXML/image@main/img/v2-2cdedcdf752a00bafc1ee9d9901580c0_720w.webp)

> [Java JVM 运行机制及基本原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/25713880)
>
> [Java内存区域详解（重点） | JavaGuide](https://javaguide.cn/java/jvm/memory-area.html#程序计数器)

#### 类加载器

1. **Bootstrap ClassLoader**：称之为启动类加载器，是最顶层的类加载器，**负责加载JDK中的核心类库，如 rt.jar、resources.jar、charsets.jar等**。由C++编写
2. **Extension ClassLoader**：称之为扩展类加载器，负责加载Java的扩展类库，默认加载$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。
3. **App ClassLoader**：称之为系统类加载器，负责加载应用程序classpath目录下所有jar和class文件。

#### 程序计数器

在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以**每条线程都会有一个独立的程序计数器**。

程序计数器仅占很小的一块内存空间。

当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址。如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。

程序计数器不会抛出 OutOfMemoryError（内存不足错误）。

#### Java堆 Heap

> [!IMPORTant]
>
> *线程共享*
>
> 此内存区域的唯一目的就是存放**对象实例**，几乎所有的对象实例以及数组都在这里分配内存

![堆内存结构](https://cdn.jsdelivr.net/gh/PaoMoXML/image@main/img/hotspot-heap-structure.png)

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

#### 方法区

> [!IMPORTANT]
>
> *线程共享*
>
> 存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**

在JDK8以前，使用*永久代*的方式来实现方法区，JDK8以后，永久代的概念被废弃了，方法区改用和 JRockit、J9一样的在**本地内存中实现的元空间（Meta Space）来代替**，好处是元空间会在运行时根据需要动态调整，只要没有超过当前进程可用的内存上限（32位和64位系统各不相同），就不会出现溢出的问题。

**方法区也可以被垃圾回收，但条件非常严苛，必须在该类没有任何引用的情况下**

#### Java栈

> [!IMPORTANT]
>
> *线程私有*

##### 虚拟机栈（JVM栈、VM Stack）

Java 虚拟机栈的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。

除了一些 Native 方法调用是通过本地方法栈实现的(后面会提到)，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）

在Java栈中**只保存基础数据类型**和对象的**引用**，**注意只是对象的引用而不是对象本身哦**，对象是保存在堆区中的

**拓展知识：像String、Integer、Byte、Short、Long、Boolean等等包装类型，它们是存放于堆中的。**

**栈内创建的基本类型数据在超出其作用域后，会被自动释放掉，它不由JVM GC管理**。而在栈内创建的引用类型实例，则还是由JVM GC管理。

##### 本地方法栈（Native Method Stack）

本地方法栈的功能和JVM栈非常类似，区别在于虚拟机栈执行的是Java方法，本地方法栈执行的是本地（Native）方法服务，存储的也是本地方法的局部变量表，本地方法的操作数栈等信息。

栈内的数据在超出其作用域后，会被自动释放掉，**它不由JVM GC管理。**

本地方法都不是使用Java语言编写的，它们可能由C或其他语言编写，本地方法也不由JVM去运行，所以本地方法的运行不受JVM管理。

#### 常量池

1. 运行时常量池：运行时常量池是方法区（Method Area）的一部分，运行时常量池中存储的，是基本类型的数据和对象的引用，注意**是对象的引用而不是对象实例本身**哦。

   Java虚拟机在加载Class文件时，Class文件内容里常量池的数据会放入运行时常量池。每一个加载好的Class对象里都会有一个运行时常量池。

2. 字符串常量池和包装类常量池：

   1. `String`：JDK7之后，字符串常量池从方法区迁移到了堆区，它的底层实现可以理解为是一个HashTable。Java虚拟机中只会存在一份字符串常量池。字符串常量池里，存放的数据可以是引用也可以是对象实例本身。可以使用`String.intern()`将新的常量放入池中。
   2. `Byte、Short、Integer、Long、Character`：这5种包装类都默认创建了数值**[-128 , 127]**的缓存数据。**当这5个类型的数据不在这个区间内的时候，将会去创建新的对象，并且不会将这些新的对象放入常量池中。**`Boolean`也实现了常量池。 *`Float、Double` 这两个浮点类型没有实现常量池* 。

#### GC

[Java性能优化之JVM GC（垃圾回收机制） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/25539690)

