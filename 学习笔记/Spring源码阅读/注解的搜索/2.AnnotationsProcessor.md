### 用于处理注解的回调接口

```java
/**
 * 用于处理注解的回调接口
 *
 * @param <C> the context type 入参类型
 * @param <R> the result type 返回值类型
 * @author Phillip Webb
 * @since 5.2
 * @see AnnotationsScanner
 * @see TypeMappedAnnotations
 */
@FunctionalInterface
interface AnnotationsProcessor<C, R> {

   /**
    * 在即将处理聚合时调用。此方法可能会返回一个非空结果，以缩短任何进一步的处理
    * @param context 要被处理的上下文
    * @param aggregateIndex 要被处理的聚合索引
    * @return 如果不需要进一步处理，则为非null结果
    */
   @Nullable
   default R doWithAggregate(C context, int aggregateIndex) {
      return null;
   }

   /**
    * 当可以处理注释数组时调用。此方法可能会返回一个非空结果，以缩短任何进一步的处理。
    * @param context 要被处理的上下文
    * @param aggregateIndex 要被处理的聚合索引
    * @param source 注解的来源
    * @param annotations 要处理的注解（此数组可能包含null元素）
    * @return 如果不需要进一步处理，则为非null结果
    */
   @Nullable
   R doWithAnnotations(C context, int aggregateIndex, @Nullable Object source, Annotation[] annotations);

   /**
    * 获取要返回的最终结果。默认情况下，此方法返回最后一个处理结果
    * @param result the last early exit result, or {@code null} if none
    * @return the final result to be returned to the caller
    */
   @Nullable
   default R finish(@Nullable R result) {
      return result;
   }

}
```

#### 实现类`MergedAnnotationFinder`

> 该实现类会在[注解的搜索](./1.MergedAnnotations.md)中使用

```java
private class MergedAnnotationFinder<A extends Annotation>
			implements AnnotationsProcessor<Object, MergedAnnotation<A>> {
		//需要搜索的注解类型
		private final Object requiredType;
		
    	//结果断言
		@Nullable
		private final Predicate<? super MergedAnnotation<A>> predicate;
    
		//结果选择器（如果有多个结果，就可通过它来获取需要的结果）
		private final MergedAnnotationSelector<A> selector;

		@Nullable
		private MergedAnnotation<A> result;

		MergedAnnotationFinder(Object requiredType, @Nullable Predicate<? super MergedAnnotation<A>> predicate,
				@Nullable MergedAnnotationSelector<A> selector) {

			this.requiredType = requiredType;
			this.predicate = predicate;
            //默认最先获取的
			this.selector = (selector != null ? selector : MergedAnnotationSelectors.nearest());
		}

		@Override
		@Nullable
		public MergedAnnotation<A> doWithAggregate(Object context, int aggregateIndex) {
			return this.result;
		}

		@Override
		@Nullable
		public MergedAnnotation<A> doWithAnnotations(Object type, int aggregateIndex,
				@Nullable Object source, Annotation[] annotations) {

			for (Annotation annotation : annotations) {
				if (annotation != null && !annotationFilter.matches(annotation)) {
					MergedAnnotation<A> result = process(type, aggregateIndex, source, annotation);
					if (result != null) {
						return result;
					}
				}
			}
			return null;
		}
		
    	/**
    	 * @param type 理论上就是requiredType
    	 * @param aggregateIndex 聚合索引
    	 * @param source 注解本体
    	 * @param annotation 搜索到的注解之一
    	 */
		@Nullable
		private MergedAnnotation<A> process(
				Object type, int aggregateIndex, @Nullable Object source, Annotation annotation) {
			
            //处理可重入注解
			Annotation[] repeatedAnnotations = repeatableContainers.findRepeatedAnnotations(annotation);
			if (repeatedAnnotations != null) {
				return doWithAnnotations(type, aggregateIndex, source, repeatedAnnotations);
			}
            //获取AnnotationTypeMappings
            //详见2.1AnnotationTypeMapping.md
			AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(
					annotation.annotationType(), repeatableContainers, annotationFilter);
			for (int i = 0; i < mappings.size(); i++) {
				AnnotationTypeMapping mapping = mappings.get(i);
				if (isMappingForType(mapping, annotationFilter, this.requiredType)) {
					MergedAnnotation<A> candidate = TypeMappedAnnotation.createIfPossible(
							mapping, source, annotation, aggregateIndex, IntrospectionFailureLogger.INFO);
					if (candidate != null && (this.predicate == null || this.predicate.test(candidate))) {
						if (this.selector.isBestCandidate(candidate)) {
							return candidate;
						}
						updateLastResult(candidate);
					}
				}
			}
			return null;
		}

		private void updateLastResult(MergedAnnotation<A> candidate) {
			MergedAnnotation<A> lastResult = this.result;
			this.result = (lastResult != null ? this.selector.select(lastResult, candidate) : candidate);
		}

		@Override
		@Nullable
		public MergedAnnotation<A> finish(@Nullable MergedAnnotation<A> result) {
			return (result != null ? result : this.result);
		}
	}
```

