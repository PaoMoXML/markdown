```java
abstract class AnnotationsScanner {
    /**
     * 搜索类中的注解
     * @param context 目标注解
     * @param source 搜索对象
     * @param searchStrategy 搜索策略
     * @param processor 处理者，用于判断存在注解是否是我们需要查找的注解
     */
    @Nullable
    private static <C, R> R processClass(C context, Class<?> source,
          SearchStrategy searchStrategy, AnnotationsProcessor<C, R> processor) {

       switch (searchStrategy) {
          case DIRECT:
             return processElement(context, source, processor);
          case INHERITED_ANNOTATIONS:
             return processClassInheritedAnnotations(context, source, searchStrategy, processor);
          case SUPERCLASS:
             return processClassHierarchy(context, source, processor, false, false);
          case TYPE_HIERARCHY:
             return processClassHierarchy(context, source, processor, true, false);
          case TYPE_HIERARCHY_AND_ENCLOSING_CLASSES:
             return processClassHierarchy(context, source, processor, true, true);
       }
       throw new IllegalStateException("Unsupported search strategy " + searchStrategy);
    }
}
```

### 在搜索注解前需要了解的方法

1. `getDeclaredAnnotations`

   ```java
   abstract class AnnotationsScanner {
       /**
        * 获取source上定义的注解
        * @param source 被搜索的源对象
        * @param defensive 
        */
       static Annotation[] getDeclaredAnnotations(AnnotatedElement source, boolean defensive) {
           //缓存
          boolean cached = false;
           //从缓存中获取
          Annotation[] annotations = declaredAnnotationCache.get(source);
          if (annotations != null) {
             cached = true;
          }
          else {
              //获取直接声明的所有注解（不包含继承的）
             annotations = source.getDeclaredAnnotations();
             if (annotations.length != 0) {
                boolean allIgnored = true;
                for (int i = 0; i < annotations.length; i++) {
                   Annotation annotation = annotations[i];
                    //isIgnorable：AnnotationFilter.PLAIN.matches(annotationType) 过滤掉不需要的注解
                    //AttributeMethods.forAnnotationType：检验注解中的方法是否能正常调用
                   if (isIgnorable(annotation.annotationType()) ||
                         !AttributeMethods.forAnnotationType(annotation.annotationType()).isValid(annotation)) {
                      annotations[i] = null;
                   }
                   else {
                      allIgnored = false;
                   }
                }
                annotations = (allIgnored ? NO_ANNOTATIONS : annotations);
                if (source instanceof Class || source instanceof Member) {
                   declaredAnnotationCache.put(source, annotations);
                   cached = true;
                }
             }
          }
          if (!defensive || annotations.length == 0 || !cached) {
             return annotations;
          }
          return annotations.clone();
       }
       
       /**
        * 是否是没有等级的 true：没有层级，false：有层级
        * @param source 处理的源对象
        * @param searchStrategy 搜索策略
        */
       private static boolean isWithoutHierarchy(AnnotatedElement source, SearchStrategy searchStrategy) {
   		if (source == Object.class) {
   			return true;
   		}
   		if (source instanceof Class) {
   			Class<?> sourceClass = (Class<?>) source;
               //没有超类-->超类是Object.class 或者 没有接口
   			boolean noSuperTypes = (sourceClass.getSuperclass() == Object.class &&
   					sourceClass.getInterfaces().length == 0);
               //搜索等级如果是最高的，那还需要判断 是否封闭类&&noSuperTypes，否则直接返回noSuperTypes
   			return (searchStrategy == SearchStrategy.TYPE_HIERARCHY_AND_ENCLOSING_CLASSES ? noSuperTypes &&
   					sourceClass.getEnclosingClass() == null : noSuperTypes);
   		}
   		if (source instanceof Method) {
   			Method sourceMethod = (Method) source;
               //该方法是否是私有方法 或者 声明方法的Class对象是否有层级
               //猜想：如果是私有方法，就肯定不是从别的方法重写或实现的，所以没有层级；如果声明这个方法的类没有层级，那这个方法也就不是从别的方法重写或实现的
   			return (Modifier.isPrivate(sourceMethod.getModifiers()) ||
   					isWithoutHierarchy(sourceMethod.getDeclaringClass(), searchStrategy));
   		}
   		return true;
   	}
   }
   ```


#### `DIRECT`

> 详见[`processElement`](./3.processElement.md)

#### `INHERITED_ANNOTATIONS`

```java
private static <C, R> R processClassInheritedAnnotations(C context, Class<?> source,
      SearchStrategy searchStrategy, AnnotationsProcessor<C, R> processor) {

   try {
       //判断是否没有层级
      if (isWithoutHierarchy(source, searchStrategy)) {
          //详见3.processElement.md
         return processElement(context, source, processor);
      }
      Annotation[] relevant = null;
       //直译
      int remaining = Integer.MAX_VALUE;
      int aggregateIndex = 0;
      Class<?> root = source;
      while (source != null && source != Object.class && remaining > 0 &&
            !hasPlainJavaAnnotationsOnly(source)) {
         R result = processor.doWithAggregate(context, aggregateIndex);
         if (result != null) {
            return result;
         }
         Annotation[] declaredAnnotations = getDeclaredAnnotations(source, true);
         if (relevant == null && declaredAnnotations.length > 0) {
            relevant = root.getAnnotations();
            remaining = relevant.length;
         }
         for (int i = 0; i < declaredAnnotations.length; i++) {
            if (declaredAnnotations[i] != null) {
               boolean isRelevant = false;
               for (int relevantIndex = 0; relevantIndex < relevant.length; relevantIndex++) {
                  if (relevant[relevantIndex] != null &&
                        declaredAnnotations[i].annotationType() == relevant[relevantIndex].annotationType()) {
                     isRelevant = true;
                     relevant[relevantIndex] = null;
                     remaining--;
                     break;
                  }
               }
               if (!isRelevant) {
                  declaredAnnotations[i] = null;
               }
            }
         }
         result = processor.doWithAnnotations(context, aggregateIndex, source, declaredAnnotations);
         if (result != null) {
            return result;
         }
         source = source.getSuperclass();
         aggregateIndex++;
      }
   }
   catch (Throwable ex) {
      AnnotationUtils.handleIntrospectionFailure(source, ex);
   }
   return null;
}
```
