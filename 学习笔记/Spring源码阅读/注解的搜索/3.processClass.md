```java
abstract class AnnotationsScanner {
    /**
     * @param context 目标注解
     * @param source 搜索对象
     * @param searchStrategy 搜索策略
     * @param processor 处理者，用于判断存在注解是否是我们需要查找的注解
     */
    @Nullable
    private static <C, R> R processClass(C context, Class<?> source,
          SearchStrategy searchStrategy, AnnotationsProcessor<C, R> processor) {

       switch (searchStrategy) {
          case DIRECT:
             return processElement(context, source, processor);
          case INHERITED_ANNOTATIONS:
             return processClassInheritedAnnotations(context, source, searchStrategy, processor);
          case SUPERCLASS:
             return processClassHierarchy(context, source, processor, false, false);
          case TYPE_HIERARCHY:
             return processClassHierarchy(context, source, processor, true, false);
          case TYPE_HIERARCHY_AND_ENCLOSING_CLASSES:
             return processClassHierarchy(context, source, processor, true, true);
       }
       throw new IllegalStateException("Unsupported search strategy " + searchStrategy);
    }
}
```

### 在搜索注解前需要了解的方法

1. `getDeclaredAnnotations`

   ```java
   abstract class AnnotationsScanner {
       static Annotation[] getDeclaredAnnotations(AnnotatedElement source, boolean defensive) {
           //缓存
          boolean cached = false;
           //从缓存中获取
          Annotation[] annotations = declaredAnnotationCache.get(source);
          if (annotations != null) {
             cached = true;
          }
          else {
              //获取直接声明的所有注解（不包含继承的）
             annotations = source.getDeclaredAnnotations();
             if (annotations.length != 0) {
                boolean allIgnored = true;
                for (int i = 0; i < annotations.length; i++) {
                   Annotation annotation = annotations[i];
                    //isIgnorable：AnnotationFilter.PLAIN.matches(annotationType) 过滤掉不需要的注解
                    //AttributeMethods.forAnnotationType：检验注解中的方法是否能正常调用
                   if (isIgnorable(annotation.annotationType()) ||
                         !AttributeMethods.forAnnotationType(annotation.annotationType()).isValid(annotation)) {
                      annotations[i] = null;
                   }
                   else {
                      allIgnored = false;
                   }
                }
                annotations = (allIgnored ? NO_ANNOTATIONS : annotations);
                if (source instanceof Class || source instanceof Member) {
                   declaredAnnotationCache.put(source, annotations);
                   cached = true;
                }
             }
          }
          if (!defensive || annotations.length == 0 || !cached) {
             return annotations;
          }
          return annotations.clone();
       }
   }
   ```


#### `DIRECT`

```java
abstract class AnnotationsScanner {
    @Nullable
    private static <C, R> R processElement(C context, AnnotatedElement source,
          AnnotationsProcessor<C, R> processor) {

       try {
           //processor中如果已经有结果，就直接返回，否则走doWithAnnotations
          R result = processor.doWithAggregate(context, 0);
          return (result != null ? result : processor.doWithAnnotations(
              //getDeclaredAnnotations是获取对象上的注解
             context, 0, source, getDeclaredAnnotations(source, false)));
       }
       catch (Throwable ex) {
          AnnotationUtils.handleIntrospectionFailure(source, ex);
       }
       return null;
    }
}
```
