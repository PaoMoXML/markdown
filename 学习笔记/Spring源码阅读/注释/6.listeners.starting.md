> 此处使用的`listeners`是在
> ```java
> SpringApplicationRunListeners listeners = getRunListeners(args)
> ```
>
> 处获取的

```java
public class SpringApplication {
    
    public ConfigurableApplicationContext run(String... args) {
        //...
        listeners.starting(bootstrapContext, this.mainApplicationClass);
        //...
    }
    
}

class SpringApplicationRunListeners {
    
	void starting(ConfigurableBootstrapContext bootstrapContext, Class<?> mainApplicationClass) {
		doWithListeners(
            //stepName
            "spring.boot.application.starting", 
            //listenerAction
            (listener) -> listener.starting(bootstrapContext),
            //stepAction
				(step) -> {
					if (mainApplicationClass != null) {
						step.tag("mainApplicationClass", mainApplicationClass.getName());
					}
				}
        );
	}
    
	private void doWithListeners(String stepName, Consumer<SpringApplicationRunListener> listenerAction,
			Consumer<StartupStep> stepAction) {
        //applicationStartup 在spring启动时初始化为 DefaultApplicationStartup
        //其中的start方法返回值为内部类`DefaultStartupStep`
        //此类是默认的“无操作”ApplicationStartup实现。 此变体是为最小化开销而设计的，并且不记录事件
		StartupStep step = this.applicationStartup.start(stepName);
        //循环listeners中的类，并执行 listenerAction中定义的内容 --> listener.starting(bootstrapContext)
		this.listeners.forEach(listenerAction);
		if (stepAction != null) {
			stepAction.accept(step);
		}
		step.end();
	}
    
}

```

在`SpringBoot`启动时，获取到的`SpringApplicationRunListener`实现类为：`EventPublishingRunListener`，所以

```java
this.listeners.forEach(listenerAction);
```

此处实际上执行的就是`EventPublishingRunListener`中的方法

```java
/**
 * SpringApplicationRunListener发布SpringApplicationEvents。
 * 对在实际刷新上下文之前激发的事件使用内部ApplicationEventMultimaster。
 */
public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered {

   private final SpringApplication application;

   private final String[] args;

   private final SimpleApplicationEventMulticaster initialMulticaster;

   public EventPublishingRunListener(SpringApplication application, String[] args) {
       //SpringApplication对象
      this.application = application;
      this.args = args;
       //事件广播类
      this.initialMulticaster = new SimpleApplicationEventMulticaster();
      for (ApplicationListener<?> listener : application.getListeners()) {
         this.initialMulticaster.addApplicationListener(listener);
      }
   }

   @Override
   public int getOrder() {
      return 0;
   }

   @Override
   public void starting(ConfigurableBootstrapContext bootstrapContext) {
      this.initialMulticaster
            .multicastEvent(new ApplicationStartingEvent(bootstrapContext, this.application, this.args));
   }

   @Override
   public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext,
         ConfigurableEnvironment environment) {
      this.initialMulticaster.multicastEvent(
            new ApplicationEnvironmentPreparedEvent(bootstrapContext, this.application, this.args, environment));
   }

   @Override
   public void contextPrepared(ConfigurableApplicationContext context) {
      this.initialMulticaster
            .multicastEvent(new ApplicationContextInitializedEvent(this.application, this.args, context));
   }

   @Override
   public void contextLoaded(ConfigurableApplicationContext context) {
      for (ApplicationListener<?> listener : this.application.getListeners()) {
         if (listener instanceof ApplicationContextAware) {
            ((ApplicationContextAware) listener).setApplicationContext(context);
         }
         context.addApplicationListener(listener);
      }
      this.initialMulticaster.multicastEvent(new ApplicationPreparedEvent(this.application, this.args, context));
   }

   @Override
   public void started(ConfigurableApplicationContext context, Duration timeTaken) {
      context.publishEvent(new ApplicationStartedEvent(this.application, this.args, context, timeTaken));
      AvailabilityChangeEvent.publish(context, LivenessState.CORRECT);
   }

   @Override
   public void ready(ConfigurableApplicationContext context, Duration timeTaken) {
      context.publishEvent(new ApplicationReadyEvent(this.application, this.args, context, timeTaken));
      AvailabilityChangeEvent.publish(context, ReadinessState.ACCEPTING_TRAFFIC);
   }

   @Override
   public void failed(ConfigurableApplicationContext context, Throwable exception) {
      ApplicationFailedEvent event = new ApplicationFailedEvent(this.application, this.args, context, exception);
      if (context != null && context.isActive()) {
         // Listeners have been registered to the application context so we should
         // use it at this point if we can
         context.publishEvent(event);
      }
      else {
         // An inactive context may not have a multicaster so we use our multicaster to
         // call all the context's listeners instead
         if (context instanceof AbstractApplicationContext) {
            for (ApplicationListener<?> listener : ((AbstractApplicationContext) context)
                  .getApplicationListeners()) {
               this.initialMulticaster.addApplicationListener(listener);
            }
         }
         this.initialMulticaster.setErrorHandler(new LoggingErrorHandler());
         this.initialMulticaster.multicastEvent(event);
      }
   }

   private static class LoggingErrorHandler implements ErrorHandler {

      private static final Log logger = LogFactory.getLog(EventPublishingRunListener.class);

      @Override
      public void handleError(Throwable throwable) {
         logger.warn("Error calling ApplicationEventListener", throwable);
      }

   }

}
```