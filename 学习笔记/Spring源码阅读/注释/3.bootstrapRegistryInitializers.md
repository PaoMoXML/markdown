### `BootstrapRegistryInitializer`

> `BootstrapRegistryInitializer`是一个函数式接口
>
> ```java
> @FunctionalInterface
> public interface BootstrapRegistryInitializer {
> 
> 	/**
> 	 * Initialize the given {@link BootstrapRegistry} with any required registrations.
> 	 * @param registry the registry to initialize
> 	 */
> 	void initialize(BootstrapRegistry registry);
> }
> ```
>

#### 1.`BootstrapRegistry`接口

>  `BootstrapRegistry`中定义了五个方法，一个内部类，一个内部枚举

```java
/**
 * Register a specific type with the registry. If the specified type has already been
 * registered and has not been obtained as a {@link Scope#SINGLETON singleton}, it
 * will be replaced.
 * @param <T> the instance type
 * @param type the instance type
 * @param instanceSupplier the instance supplier
 */
<T> void register(Class<T> type, InstanceSupplier<T> instanceSupplier);

/**
 * Register a specific type with the registry if one is not already present.
 * @param <T> the instance type
 * @param type the instance type
 * @param instanceSupplier the instance supplier
 */
<T> void registerIfAbsent(Class<T> type, InstanceSupplier<T> instanceSupplier);

/**
 * Return if a registration exists for the given type.
 * @param <T> the instance type
 * @param type the instance type
 * @return {@code true} if the type has already been registered
 */
<T> boolean isRegistered(Class<T> type);

/**
 * Return any existing {@link InstanceSupplier} for the given type.
 * @param <T> the instance type
 * @param type the instance type
 * @return the registered {@link InstanceSupplier} or {@code null}
 */
<T> InstanceSupplier<T> getRegisteredInstanceSupplier(Class<T> type);

/**
 * Add an {@link ApplicationListener} that will be called with a
 * {@link BootstrapContextClosedEvent} when the {@link BootstrapContext} is closed and
 * the {@link ApplicationContext} has been prepared.
 * @param listener the listener to add
 */
void addCloseListener(ApplicationListener<BootstrapContextClosedEvent> listener);
```

##### 1.2`InstanceSupplier`函数式接口

`InstanceSupplier`是`BootstrapRegistry`的一个内部类

```java
/**
 * Supplier used to provide the actual instance when needed.
 *
 * @param <T> the instance type
 * @see Scope
 */
@FunctionalInterface
interface InstanceSupplier<T> {

    /**
     * Factory method used to create the instance when needed.
     * @param context the {@link BootstrapContext} which may be used to obtain other
     * bootstrap instances.
     * @return the instance
     */
    T get(BootstrapContext context);

    /**
     * Return the scope of the supplied instance.
     * @return the scope
     * @since 2.4.2
     */
    default Scope getScope() {
        return Scope.SINGLETON;
    }

    /**
     * Return a new {@link InstanceSupplier} with an updated {@link Scope}.
     * @param scope the new scope
     * @return a new {@link InstanceSupplier} instance with the new scope
     * @since 2.4.2
     */
    default InstanceSupplier<T> withScope(Scope scope) {
        Assert.notNull(scope, "Scope must not be null");
        InstanceSupplier<T> parent = this;
        return new InstanceSupplier<T>() {

            @Override
            public T get(BootstrapContext context) {
                return parent.get(context);
            }

            @Override
            public Scope getScope() {
                return scope;
            }

        };
    }

    /**
     * Factory method that can be used to create an {@link InstanceSupplier} for a
     * given instance.
     * @param <T> the instance type
     * @param instance the instance
     * @return a new {@link InstanceSupplier}
     */
    static <T> InstanceSupplier<T> of(T instance) {
        return (registry) -> instance;
    }

    /**
     * Factory method that can be used to create an {@link InstanceSupplier} from a
     * {@link Supplier}.
     * @param <T> the instance type
     * @param supplier the supplier that will provide the instance
     * @return a new {@link InstanceSupplier}
     */
    static <T> InstanceSupplier<T> from(Supplier<T> supplier) {
        return (registry) -> (supplier != null) ? supplier.get() : null;
    }

}
```

##### 1.3`Scope`枚举

```java
/**
 * The scope of an instance.
 * @since 2.4.2
 */
enum Scope {

   /**
    * A singleton instance. The {@link InstanceSupplier} will be called only once and
    * the same instance will be returned each time.
    */
   SINGLETON,

   /**
    * A prototype instance. The {@link InstanceSupplier} will be called whenever an
    * instance is needed.
    */
   PROTOTYPE

}
```

#### 4.根据测试工程`spring-boot-smoke-test-bootstrap-registry`

```java
public static void main(String[] args) {
   // This example shows how a Bootstrapper can be used to register a custom
   // SubversionClient that still has access to data provided in the
   // application.properties file
   SpringApplication application = new SpringApplication(SampleBootstrapRegistryApplication.class);
    //在此处的入参为 BootstrapRegistryInitializer
    //构造 BootstrapRegistryInitializer 的入参为 MySubversionClient 的构造函数 
    //MySubversionClient继承了SubversionClient 实际执行的是下面方法 ↓
	//public SubversionClient(SubversionServerCertificate serverCertificate) {
	//	this.serverCertificate = serverCertificate;
	//}
    // 涉及到 withCustomClient 方法 ↓↓
   application.addBootstrapRegistryInitializer(SubversionBootstrap.withCustomClient(MySubversionClient::new));
   application.run(args);
}

/**
 * Return a {@link BootstrapRegistryInitializer} for the given client factory.
 *
 * @param clientFactory the client factory
 * 是一个入参为：SubversionServerCertificate 出参为：SubversionClient 的函数
 * 
 * @return a {@link BootstrapRegistryInitializer} instance
 * 返回值是 BootstrapRegistryInitializer 的实例（详见标题[BootstrapRegistryInitializer]）
 * 就需要定义BootstrapRegistryInitializer函数，其入参为 BootstrapRegistry
 */
public static BootstrapRegistryInitializer withCustomClient(
        Function<SubversionServerCertificate, SubversionClient> clientFactory) {
    //此处使用了BootstrapRegistry 中的 register方法（详见标题[2]）
    //就需要继续定义InstanceSupplier函数
    return (registry) -> registry.register(SubversionClient.class,
            (bootstrapContext) -> createSubversionClient(bootstrapContext, clientFactory));
}

private static SubversionClient createSubversionClient(BootstrapContext bootstrapContext,
        Function<SubversionServerCertificate, SubversionClient> clientFactory) {
    return clientFactory.apply(bootstrapContext.get(SubversionServerCertificate.class));
}
```

> **run方法中的`DefaultBootstrapContext bootstrapContext = createBootstrapContext();`**将会执行以下步骤
>
> 1. 注册`SubversionClient`需要提供`SubversionClient.class` 和实例化他的方法（构造函数）
> 2. `SubversionClient`实例化-->实例化需要用到`SubversionServerCertificate`
> 3. `SubversionServerCertificate`从`BootstrapContext`中取
> 4. 将`SubversionClient.class`和实例化方法放到`DefaultBootstrapContext.instanceSuppliers`（`Map<Class<?>, InstanceSupplier<?>>`）中

